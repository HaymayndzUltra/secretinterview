import {
  BrowserWindow,
  app,
  ipcMain,
  desktopCapturer,
  session,
} from "electron";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
import Prism from "prismjs";
import axios from "axios";
import FormData from "form-data";
import fs from "fs";
import path from "path";
import { Buffer } from "buffer";
import { createClient, LiveTranscriptionEvents } from "@deepgram/sdk";
import LocalAsrManager from "./local-asr/LocalAsrManager";

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
import electronSquirrelStartup from "electron-squirrel-startup";

type LocalLLMEngineType = "ollama" | "lmstudio" | "vllm" | "openaiCompatible";

interface LocalLLMConfig {
  engine: LocalLLMEngineType;
  baseUrl: string;
  model: string;
  temperature?: number;
  topP?: number;
  maxTokens?: number;
}

interface KnowledgeLayerConfig {
  projectFile?: string;
}

interface AppConfig {
  llm: LocalLLMConfig;
  primaryLanguage?: string;
  secondaryLanguage?: string;
  deepgram_api_key?: string;
  localAsr?: Record<string, any>;
  knowledge?: KnowledgeLayerConfig;
  // Legacy fields retained for backward compatibility
  openai_key?: string;
  api_base?: string;
  gpt_model?: string;
  api_call_method?: string;
}

if (electronSquirrelStartup) {
  app.quit();
}

const createWindow = (): void => {
  const mainWindow = new BrowserWindow({
    height: 1000,
    width: 1300,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
      webSecurity: false,
    },
  });

  mainWindow.webContents.session.webRequest.onHeadersReceived(
    (details, callback) => {
      callback({
        responseHeaders: {
          ...details.responseHeaders,
          "Content-Security-Policy": [
            "default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' blob:; connect-src 'self' http://localhost:* https://localhost:* data:;",
          ],
        },
      });
    }
  );

  mainWindow.webContents.session.setPermissionRequestHandler(
    (webContents, permission, callback) => {
      if (permission === "media") {
        callback(true);
      } else {
        callback(false);
      }
    }
  );

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY + "#/main_window");
//  mainWindow.webContents.openDevTools();

  mainWindow.webContents.on("did-finish-load", () => {
    mainWindow.webContents.executeJavaScript(`
      console.log('Applied CSP:', document.querySelector('meta[http-equiv="Content-Security-Policy"]')?.getAttribute('content'));
    `);
  });
};

ipcMain.handle(
  "save-temp-audio-file",
  async (event, audioBuffer: ArrayBuffer) => {
    try {
      const tempFilePath = path.join(
        app.getPath("temp"),
        `temp_audio_${Date.now()}.wav`
      );
      fs.writeFileSync(tempFilePath, Buffer.from(audioBuffer));
      return tempFilePath;
    } catch (error) {
      throw error;
    }
  }
);

ipcMain.handle(
  "transcribe-audio-file",
  async (event, filePath: string, config) => {
    try {
      const formData = new FormData();
      formData.append("file", fs.createReadStream(filePath), "audio.wav");
      formData.append("model", "whisper-1");

      if (config.primaryLanguage && config.primaryLanguage !== "auto") {
        formData.append("language", config.primaryLanguage);
      }
      if (config.secondaryLanguage) {
        formData.append(
          "prompt",
          `This audio may contain ${config.primaryLanguage} and ${config.secondaryLanguage}.`
        );
      }

      const baseUrl = normalizeApiBaseUrl(config.api_base);
      const apiUrl = `${baseUrl}/audio/transcriptions`;
      const response = await axios.post(apiUrl, formData, {
        headers: {
          ...formData.getHeaders(),
          Authorization: `Bearer ${config.openai_key}`,
        },
        maxContentLength: Infinity,
        maxBodyLength: Infinity,
      });

      return response.data;
    } catch (error) {
      throw error;
    } finally {
      fs.unlinkSync(filePath);
    }
  }
);

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the
// dock icon is clicked and there are no other windows open.
app.on("window-all-closed", () => {
  localAsrManager.stopSession().catch((error) => {
    console.warn("Failed to stop local ASR on window close", error);
  });
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

import ElectronStore from "electron-store";

interface StoreSchema {
  config: AppConfig;
}

type TypedElectronStore = ElectronStore<StoreSchema> & {
  get: <K extends keyof StoreSchema>(key: K) => StoreSchema[K];
  set: <K extends keyof StoreSchema>(key: K, value: StoreSchema[K]) => void;
  clear: () => void;
};

const store = new ElectronStore<StoreSchema>() as TypedElectronStore;
const localAsrManager = new LocalAsrManager();

const DEFAULT_PROJECT_FILE = "current_project.md";

function ensureDirectoryExists(directoryPath: string) {
  if (!fs.existsSync(directoryPath)) {
    fs.mkdirSync(directoryPath, { recursive: true });
  }
}

function getKnowledgeRoot(): string {
  return path.join(app.getAppPath(), "knowledge");
}

function getPermanentKnowledgeDir(): string {
  return path.join(getKnowledgeRoot(), "permanent");
}

function getProjectKnowledgeDir(): string {
  return path.join(getKnowledgeRoot(), "project");
}

const DEFAULT_CONFIG: AppConfig = {
  llm: {
    engine: "ollama",
    baseUrl: "http://localhost:11434",
    model: "llama3.1",
    temperature: 0.7,
    topP: 0.9,
    maxTokens: 1024,
  },
  primaryLanguage: "auto",
  secondaryLanguage: undefined,
  deepgram_api_key: "",
  localAsr: {},
  knowledge: {
    projectFile: DEFAULT_PROJECT_FILE,
  },
};

function mapLegacyLlmConfig(raw: any): Partial<LocalLLMConfig> | undefined {
  if (!raw) {
    return undefined;
  }

  if (raw.api_base || raw.gpt_model) {
    return {
      engine: "openaiCompatible",
      baseUrl: typeof raw.api_base === "string" && raw.api_base.length > 0
        ? raw.api_base
        : "http://localhost:1234/v1",
      model: raw.gpt_model || "gpt-3.5-turbo",
    };
  }

  return undefined;
}

function normalizeAppConfig(raw: any): AppConfig {
  const normalized: AppConfig = {
    ...DEFAULT_CONFIG,
    llm: { ...DEFAULT_CONFIG.llm },
    knowledge: { ...DEFAULT_CONFIG.knowledge },
    localAsr: raw?.localAsr ? { ...raw.localAsr } : { ...(DEFAULT_CONFIG.localAsr || {}) },
  };

  if (raw && typeof raw === "object") {
    if (raw.primaryLanguage !== undefined) {
      normalized.primaryLanguage = raw.primaryLanguage;
    }
    if (raw.secondaryLanguage !== undefined) {
      normalized.secondaryLanguage = raw.secondaryLanguage;
    }
    if (raw.deepgram_api_key !== undefined) {
      normalized.deepgram_api_key = raw.deepgram_api_key;
    }
    if (raw.knowledge && typeof raw.knowledge === "object") {
      normalized.knowledge = {
        ...normalized.knowledge,
        ...raw.knowledge,
      };
    }

    const llmOverrides = raw.llm || mapLegacyLlmConfig(raw) || {};
    normalized.llm = {
      ...normalized.llm,
      ...llmOverrides,
    };

    if (raw.localAsr && typeof raw.localAsr === "object") {
      normalized.localAsr = {
        ...normalized.localAsr,
        ...raw.localAsr,
      };
    }
  }

  if (!normalized.knowledge) {
    normalized.knowledge = { projectFile: DEFAULT_PROJECT_FILE };
  } else if (!normalized.knowledge.projectFile) {
    normalized.knowledge.projectFile = DEFAULT_PROJECT_FILE;
  }

  if (!normalized.llm.engine) {
    normalized.llm.engine = DEFAULT_CONFIG.llm.engine;
  }
  if (!normalized.llm.baseUrl) {
    normalized.llm.baseUrl = DEFAULT_CONFIG.llm.baseUrl;
  }
  if (!normalized.llm.model) {
    normalized.llm.model = DEFAULT_CONFIG.llm.model;
  }

  return normalized;
}

function getAppConfig(): AppConfig {
  try {
    const storedConfig = store.get("config");
    if (!storedConfig) {
      return normalizeAppConfig({});
    }
    return normalizeAppConfig(storedConfig);
  } catch (error) {
    console.warn("Failed to read stored config, using defaults", error);
    return normalizeAppConfig({});
  }
}

type ChatMessage = {
  role: "system" | "user" | "assistant";
  content: string;
};

function serializeMessageContent(content: any): string {
  if (typeof content === "string") {
    return content;
  }
  if (Array.isArray(content)) {
    return content
      .map((part) => {
        if (!part) {
          return "";
        }
        if (typeof part === "string") {
          return part;
        }
        if (part.type === "text" && typeof part.text === "string") {
          return part.text;
        }
        if (part.type === "image_url" && part.image_url && typeof part.image_url.url === "string") {
          return `[Image:${part.image_url.url}]`;
        }
        if (typeof part.content === "string") {
          return part.content;
        }
        return JSON.stringify(part);
      })
      .join("\n");
  }
  if (content && typeof content === "object") {
    if (typeof content.text === "string") {
      return content.text;
    }
    if (typeof content.content === "string") {
      return content.content;
    }
    return JSON.stringify(content);
  }
  if (content === undefined || content === null) {
    return "";
  }
  return String(content);
}

function normalizeMessages(messages: any[]): ChatMessage[] {
  if (!Array.isArray(messages)) {
    return [];
  }

  return messages
    .map((message) => {
      const role = typeof message?.role === "string" ? message.role : "user";
      const normalizedRole: ChatMessage["role"] = role === "system" || role === "assistant" ? role : "user";
      const content = serializeMessageContent(message?.content);
      return {
        role: normalizedRole,
        content,
      } as ChatMessage;
    })
    .filter((message) => message.content && message.content.trim().length > 0);
}

function trimTrailingSlash(url: string): string {
  return url.replace(/\/+$/, "");
}

function buildOllamaChatUrl(baseUrl: string): string {
  const trimmed = trimTrailingSlash(baseUrl || DEFAULT_CONFIG.llm.baseUrl);
  if (trimmed.endsWith("/api/chat")) {
    return trimmed;
  }
  if (trimmed.endsWith("/api")) {
    return `${trimmed}/chat`;
  }
  return `${trimmed}/api/chat`;
}

function buildOpenAICompatibleUrl(baseUrl: string): string {
  const trimmed = trimTrailingSlash(baseUrl || DEFAULT_CONFIG.llm.baseUrl);
  if (trimmed.endsWith("/chat/completions")) {
    return trimmed;
  }
  if (trimmed.endsWith("/v1")) {
    return `${trimmed}/chat/completions`;
  }
  return `${trimmed}/v1/chat/completions`;
}

async function executeLocalLLMRequest(
  llmConfig: LocalLLMConfig,
  messages: ChatMessage[],
  abortSignal?: AbortSignal
): Promise<string> {
  if (!llmConfig || !llmConfig.model) {
    throw new Error("Local LLM configuration is incomplete. Model name is required.");
  }

  const engine = llmConfig.engine || DEFAULT_CONFIG.llm.engine;
  const baseUrl = llmConfig.baseUrl || DEFAULT_CONFIG.llm.baseUrl;

  if (engine === "ollama") {
    const payload: any = {
      model: llmConfig.model,
      messages,
      stream: false,
      options: {},
    };

    if (typeof llmConfig.temperature === "number") {
      payload.options.temperature = llmConfig.temperature;
    }
    if (typeof llmConfig.topP === "number") {
      payload.options.top_p = llmConfig.topP;
    }
    if (typeof llmConfig.maxTokens === "number") {
      payload.options.num_predict = llmConfig.maxTokens;
    }

    const response = await axios.post(buildOllamaChatUrl(baseUrl), payload, {
      signal: abortSignal,
      timeout: 120000,
    });

    const data = response.data;
    if (data?.message?.content) {
      return data.message.content;
    }
    if (Array.isArray(data?.messages)) {
      return data.messages.map((msg: any) => msg?.content ?? "").join("\n").trim();
    }
    if (typeof data === "string") {
      return data;
    }
    if (typeof data?.response === "string") {
      return data.response;
    }
    throw new Error("Ollama response missing content.");
  }

  const url = buildOpenAICompatibleUrl(baseUrl);
  const payload: any = {
    model: llmConfig.model,
    messages,
  };
  if (typeof llmConfig.temperature === "number") {
    payload.temperature = llmConfig.temperature;
  }
  if (typeof llmConfig.topP === "number") {
    payload.top_p = llmConfig.topP;
  }
  if (typeof llmConfig.maxTokens === "number") {
    payload.max_tokens = llmConfig.maxTokens;
  }

  const response = await axios.post(url, payload, {
    signal: abortSignal,
    timeout: 120000,
  });

  const data = response.data;
  if (Array.isArray(data?.choices) && data.choices.length > 0) {
    const choice = data.choices[0];
    if (choice?.message?.content) {
      return choice.message.content;
    }
    if (choice?.text) {
      return choice.text;
    }
  }

  if (typeof data === "string") {
    return data;
  }

  throw new Error("Local LLM response missing content.");
}

try {
  const initialConfig = getAppConfig();
  store.set("config", initialConfig);
  if (initialConfig && typeof initialConfig === "object") {
    localAsrManager.configure(initialConfig.localAsr);
  }
} catch (error) {
  console.error("Failed to initialize local ASR config", error);
}

ipcMain.handle("get-config", () => {
  return getAppConfig();
});

ipcMain.handle("set-config", (event, config) => {
  const normalized = normalizeAppConfig(config);
  store.set("config", normalized);
  if (normalized && typeof normalized === "object") {
    localAsrManager.configure(normalized.localAsr);
  }
});

ipcMain.handle("parsePDF", async (event, pdfBuffer) => {
  try {
    const pdf = require("pdf-parse");
    const data = await pdf(Buffer.from(pdfBuffer), {
      max: 0,
    });
    return { text: data.text };
  } catch (error) {
    return { error: "Failed to parse PDF: " + error.message };
  }
});

ipcMain.handle("process-image", async (event, imageData) => {
  try {
    const sharp = require("sharp");
    let image;
    if (imageData.startsWith("data:image")) {
      const base64Data = imageData.split(",")[1];
      const imageBuffer = Buffer.from(base64Data, "base64");
      image = sharp(imageBuffer);
    } else {
      throw new Error(
        "Invalid image input: expected Base64 encoded image data"
      );
    }
    const metadata = await image.metadata();
    return `Image size: ${metadata.width}x${metadata.height}, Format: ${metadata.format}`;
  } catch (error) {
    return { error: "Failed to process image: " + error.message };
  }
});

ipcMain.handle("highlightCode", async (event, code, language) => {
  return Prism.highlight(code, Prism.languages[language], language);
});

app.on("before-quit", () => {
  const config = getAppConfig();
  store.set("config", config);
});

ipcMain.handle("get-system-audio-stream", async () => {
  try {
    const sources = await desktopCapturer.getSources({
      types: ["window", "screen"],
      fetchWindowIcons: false,
    });
    const audioSources = sources.filter(
      (source) =>
        source.name.toLowerCase().includes("sound") ||
        source.name.toLowerCase().includes("audio")
    );
    return audioSources.map((source) => source.id);
  } catch (error) {
    throw error;
  }
});

app.on("ready", () => {
  session.defaultSession.setDisplayMediaRequestHandler(
    (request, callback) => {
      desktopCapturer.getSources({ types: ["screen"] }).then((sources) => {
        callback({ video: sources[0], audio: "loopback" });
      });
    },
    { useSystemPicker: true }
  );

  ipcMain.handle(
    "transcribe-audio",
    async (event, audioBuffer: ArrayBuffer, config) => {
      try {
        const tempFilePath = path.join(
          app.getPath("temp"),
          `temp_audio_${Date.now()}.wav`
        );
        fs.writeFileSync(tempFilePath, Buffer.from(audioBuffer));

        const formData = new FormData();
        formData.append("file", fs.createReadStream(tempFilePath), {
          filename: "audio.wav",
          contentType: "audio/wav",
        });
        formData.append("model", "whisper-1");

        if (config.primaryLanguage && config.primaryLanguage !== "auto") {
          formData.append("language", config.primaryLanguage);
        }
        if (config.secondaryLanguage) {
          formData.append(
            "prompt",
            `This audio may contain ${config.primaryLanguage} and ${config.secondaryLanguage}.`
          );
        }

        const baseUrl = normalizeApiBaseUrl(config.api_base);
        const apiUrl = `${baseUrl}/audio/transcriptions`;
        const response = await axios.post(apiUrl, formData, {
          headers: {
            ...formData.getHeaders(),
            Authorization: `Bearer ${config.openai_key}`,
          },
          maxContentLength: Infinity,
          maxBodyLength: Infinity,
        });

        fs.unlinkSync(tempFilePath);

        return response.data;
      } catch (error) {
        throw error;
      }
    }
  );
});

ipcMain.handle("test-local-llm", async (event, config) => {
  try {
    const normalized = normalizeAppConfig(config || getAppConfig());
    const testMessages = [
      { role: "system", content: "You are a diagnostic probe." },
      { role: "user", content: "Respond with the single word: READY." },
    ];
    const result = await executeLocalLLMRequest(normalized.llm, normalizeMessages(testMessages));
    const success = typeof result === "string" && result.toUpperCase().includes("READY");
    return success
      ? { success: true }
      : { success: false, error: "Local LLM responded unexpectedly." };
  } catch (error) {
    if (axios.isAxiosError(error)) {
      if (error.response) {
        return {
          success: false,
          error: `Local LLM error: ${error.response.status} ${error.response.statusText}`,
        };
      }
      if (error.request) {
        return {
          success: false,
          error: "Local LLM did not respond. Verify the engine is running and reachable.",
        };
      }
    }
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error occurred",
    };
  }
});

ipcMain.handle("call-local-llm", async (event, { config, messages }) => {
  try {
    const normalized = normalizeAppConfig(config || getAppConfig());
    const formattedMessages = normalizeMessages(messages);
    const content = await executeLocalLLMRequest(normalized.llm, formattedMessages);
    return { content };
  } catch (error: any) {
    if (error?.name === "AbortError") {
      return { error: "AbortError" };
    }
    return { error: error?.message || "Unknown error occurred" };
  }
});

ipcMain.handle("get-desktop-sources", async () => {
  try {
    const sources = await desktopCapturer.getSources({
      types: ["window", "screen"],
    });
    return sources.map((source) => ({
      id: source.id,
      name: source.name,
      thumbnail: source.thumbnail.toDataURL(),
    }));
  } catch (error) {
    return [];
  }
});

function normalizeApiBaseUrl(url: string): string {
  if (!url) return "https://api.openai.com/v1";
  url = url.trim();
  if (!url.startsWith("http://") && !url.startsWith("https://")) {
    url = "https://" + url;
  }
  if (!url.endsWith("/v1")) {
    url = url.endsWith("/") ? url + "v1" : url + "/v1";
  }
  return url;
}

let deepgramConnection: any = null;

localAsrManager.on("transcript", (payload) => {
  const target = localAsrManager.getCurrentWebContents();
  if (target) {
    target.send("local-asr-transcript", payload);
  }
});

localAsrManager.on("status", (payload) => {
  const target = localAsrManager.getCurrentWebContents();
  if (target) {
    target.send("local-asr-status", payload);
  }
});

ipcMain.handle("start-deepgram", async (event, config) => {
  try {
    if (!config.deepgram_key) {
      throw new Error("Deepgram API key lose");
    }
    const deepgram = createClient(config.deepgram_key);
    deepgramConnection = deepgram.listen.live({
      punctuate: true,
      interim_results: false,
      model: "general",
      language: config.primaryLanguage || "en",
      encoding: "linear16",
      sample_rate: 16000,
      endpointing: 1500,
    });

    deepgramConnection.addListener(LiveTranscriptionEvents.Open, () => {
      event.sender.send("deepgram-status", { status: "open" });
    });

    deepgramConnection.addListener(LiveTranscriptionEvents.Close, () => {
      event.sender.send("deepgram-status", { status: "closed" });
    });

    deepgramConnection.addListener(
      LiveTranscriptionEvents.Transcript,
      (data: any) => {
        if (
          data &&
          data.is_final &&
          data.channel &&
          data.channel.alternatives &&
          data.channel.alternatives[0]
        ) {
          const transcript = data.channel.alternatives[0].transcript;
          if (transcript) {
            event.sender.send("deepgram-transcript", {
              transcript,
              is_final: true,
            });
          }
        }
      }
    );

    deepgramConnection.addListener(
      LiveTranscriptionEvents.Error,
      (err: any) => {
        event.sender.send("deepgram-error", err);
      }
    );

    await new Promise((resolve, reject) => {
      deepgramConnection.addListener(LiveTranscriptionEvents.Open, resolve);
      deepgramConnection.addListener(LiveTranscriptionEvents.Error, reject);
      setTimeout(() => reject(new Error("Deepgram timeout")), 10000);
    });

    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.on("send-audio-to-deepgram", (event, audioData) => {
  if (deepgramConnection) {
    try {
      const buffer = Buffer.from(audioData);
      deepgramConnection.send(buffer);
    } catch (error) {
      console.error("failed send data to Deepgram :", error);
    }
  }
});

ipcMain.handle("stop-deepgram", () => {
  if (deepgramConnection) {
    deepgramConnection.finish();
    deepgramConnection = null;
  }
});

ipcMain.handle("check-local-asr", async () => {
  return localAsrManager.getStatus();
});

ipcMain.handle("start-local-asr", async (event, options) => {
  return localAsrManager.startSession(event.sender, {
    language: options?.language,
    sampleRate: options?.sampleRate ?? 16000,
  });
});

ipcMain.on("send-audio-to-local-asr", (event, audioData) => {
  const success = localAsrManager.sendAudioChunk(audioData);
  if (!success) {
    event.sender.send("local-asr-status", {
      status: "error",
      message: "Failed to send audio to local ASR engine",
    });
  }
});

ipcMain.handle("stop-local-asr", async () => {
  await localAsrManager.stopSession();
  return { success: true };
});

function toTitleCaseFromFileName(fileName: string): string {
  return fileName
    .replace(/\.md$/i, "")
    .replace(/[-_]/g, " ")
    .replace(/\b\w/g, (char) => char.toUpperCase());
}

ipcMain.handle("load-knowledge-context", async () => {
  try {
    const config = getAppConfig();
    const permanentDir = getPermanentKnowledgeDir();
    const projectDir = getProjectKnowledgeDir();

    ensureDirectoryExists(permanentDir);
    ensureDirectoryExists(projectDir);

    const permanentFiles = fs
      .readdirSync(permanentDir)
      .filter((file) => file.toLowerCase().endsWith(".md"));

    const permanent = permanentFiles.map((fileName) => {
      const filePath = path.join(permanentDir, fileName);
      const content = fs.readFileSync(filePath, "utf-8");
      return {
        fileName,
        title: toTitleCaseFromFileName(fileName),
        content,
        path: filePath,
      };
    });

    const projectFileName = config.knowledge?.projectFile || DEFAULT_PROJECT_FILE;
    const projectPath = path.join(projectDir, projectFileName);
    let projectContent = "";
    if (fs.existsSync(projectPath)) {
      projectContent = fs.readFileSync(projectPath, "utf-8");
    }

    const availableProjects = fs
      .readdirSync(projectDir)
      .filter((file) => file.toLowerCase().endsWith(".md"));

    return {
      permanent,
      project: {
        fileName: projectFileName,
        title: toTitleCaseFromFileName(projectFileName),
        content: projectContent,
        path: projectPath,
      },
      availableProjects,
    };
  } catch (error) {
    return {
      permanent: [],
      project: null,
      availableProjects: [],
      error: error instanceof Error ? error.message : "Failed to load knowledge context",
    };
  }
});

ipcMain.handle("save-project-knowledge", async (event, { content, fileName }) => {
  try {
    const config = getAppConfig();
    const projectDir = getProjectKnowledgeDir();
    ensureDirectoryExists(projectDir);

    const targetFileName = (fileName as string) || config.knowledge?.projectFile || DEFAULT_PROJECT_FILE;
    const projectPath = path.join(projectDir, targetFileName);
    fs.writeFileSync(projectPath, content ?? "", "utf-8");

    if (targetFileName !== config.knowledge?.projectFile) {
      const updatedConfig = {
        ...config,
        knowledge: {
          ...(config.knowledge || {}),
          projectFile: targetFileName,
        },
      };
      store.set("config", updatedConfig);
    }

    return { success: true };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to save project knowledge",
    };
  }
});

ipcMain.handle("set-active-project", async (event, fileName: string) => {
  try {
    const config = getAppConfig();
    const projectDir = getProjectKnowledgeDir();
    ensureDirectoryExists(projectDir);
    const sanitizedFileName = fileName && fileName.endsWith(".md") ? fileName : `${fileName}.md`;
    const projectPath = path.join(projectDir, sanitizedFileName);
    if (!fs.existsSync(projectPath)) {
      fs.writeFileSync(projectPath, `# ${toTitleCaseFromFileName(sanitizedFileName)}\n`);
    }
    const updatedConfig = {
      ...config,
      knowledge: {
        ...(config.knowledge || {}),
        projectFile: sanitizedFileName,
      },
    };
    store.set("config", updatedConfig);
    return { success: true };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to set active project",
    };
  }
});

// Handle reading prompt template files
ipcMain.handle("read-prompt-template", async (event, templateName: string) => {
  try {
    const promptsDir = path.join(__dirname, 'prompts');
    const templatePath = path.join(promptsDir, `${templateName}.md`);
    
    // Check if file exists
    if (!fs.existsSync(templatePath)) {
      return { error: `Template '${templateName}' not found` };
    }
    
    const content = fs.readFileSync(templatePath, 'utf-8');
    return { content };
  } catch (error) {
    return { error: `Failed to read template: ${error.message}` };
  }
});

// Handle listing available prompt templates
ipcMain.handle("list-prompt-templates", async () => {
  try {
    const promptsDir = path.join(__dirname, 'prompts');
    
    // Check if prompts directory exists
    if (!fs.existsSync(promptsDir)) {
      return { templates: [] };
    }
    
    const files = fs.readdirSync(promptsDir);
    const templates = files
      .filter(file => file.endsWith('.md'))
      .map(file => ({
        name: file.replace('.md', ''),
        filename: file
      }));
    
    return { templates };
  } catch (error) {
    return { error: `Failed to list templates: ${error.message}` };
  }
});
